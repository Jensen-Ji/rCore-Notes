# 引言

>操作系统的基本目标：让应用与硬件隔离，简化应用访问硬件的难度和复杂性。实现这些功能的操作系统就是一个函数库，可以被应用访问，并通过函数来访问硬件。

**生成应用程序二进制执行代码所依赖的是以编译器为主的开发环境**
还有链接器，linker.ld文件决定代码每一段（代码段、数据段）会在内存的哪个物理地址上。
**运行应用程序执行代码所依赖的是以操作系统为主的执行环境**
对于普通APP，的确依赖操作系统
但是对于操作系统，依赖的是裸机硬件
对于内核来说：执行环境是以 硬件 + 极简运行时 为主的

**极简运行时**
全套运行时：
写hello world的时候，程序不是从main函数开始执行，在main函数之前，rust的标准库会塞一堆代码进来，这就是运行时。
这些代码的工作：
- 内存管理：准备好堆内存分配器，不然用不了String和Vec。
- 线程管理：准备好主线程的环境
- 异常处理：准备好panic发生时的打印堆栈、回溯机制
- 命令行参数：解析argv和argc
进行完这些工作，才会调用main。所以叫全套运行时。

极简运行时：
对于操作系统内核来说，代码要在裸机上启动。没有操作系统、没有标准库。也就没有了分配堆内存、管理线程等。
在按下电源键时，CPU醒来，状态是混乱的，如内存还没清零，栈指针还没设置，BSS段还没初始化。
BSS段是存放全局变量的地方。
如果这个时候直接跳转到代码里，比如想存个局部变量，或者访问全局变量，会立刻因为内存错乱而崩溃。
所以需要一段精简的代码，插在硬件启动和程序代码之间，这段代码就是极简运行时。
在rCore里，这段代码是汇编语言编写的，叫entry.asm
它的工作是：
- 设置栈
- 清空BSS段：将存放全局变量的内存全部填0
- 跳转Jump：跳转到rust_main

所以rCore的第一章，就是手搓这个精简运行时，好让Rust代码跑起来

# 应用程序执行环境与平台支持

`Cargo.toml`文件中保存项目的配置信息。

## 应用程序执行环境
![ch1-001](ch1-001.md)

应用程序、函数库、内核/操作系统、硬件平台，每一层都是一个执行环境。
API、ABI、ISA是相邻执行环境之间的接口。
越靠下越贴近底层，下层作为上层的执行环境。

>在我们通常不会注意到的地方，这些软件库还会在执行应用之前完成一些初始化工作，并在应用程序执行的时候对它进行监控。

比如main函数并不是程序的第一个执行点，在main之前，还有如初始化堆、清空BSS等。因为要写裸机程序，没有标准库做这些初始化工作，所以需要手写汇编来完成。

>在打印 Hello, world! 时使用的 println! 宏正是由 Rust 标准库 std提供的。

`println!` 不是语言特性，而是库函数，依赖std库，而std库又依赖于操作系统的`write`系统调用，所以在`#![no_std]`环境下，`println!` 宏没了，需要自己实现，让其通过SBI接口往屏幕上实现打印。

>内核作为用户态软件的执行环境，它不仅要提供系统调用接口，还需要对用户态软件的执行进行监控和管理。

内核还要有监控和管理的能力，对应后面的 Trap处理 和 任务调度 ，需要编写代码来捕获App的错误，或者强行打断App的运行。

