# 导读

在ch1实现了打印和关机，只是一个裸机应用，独占硬件，跑完就停。

特权级机制：把计算机分为两个部分
1. 划分
	- 用户态：低权限，不能直接操作硬盘、不能随意读写敏感内存、不能执行特权指令
	- 内核态：高权限，可以执行任何指令、访问任何内存
2. 隔离和保护
	- 硬件支持：不是纯软件能实现的，必须CPU硬件支持。RISC-V架构里有U Mode和S Mode。
	- 保护机制：运行在用户态的APP试图执行特权指令，CPU硬件会立即检测到并报错（触发异常），将控制权强行移交给操作系统，操作系统就会把APP杀掉，从而保护机器。
3. 系统调用：APP被限制了权限，需要执行特权指令时怎么办？
	- 申请：APP执行特殊的指令进行申请，如ecall指令
	- 穿越：CPU从用户态切换到内核态
	- 执行：操作系统检查请求是否合法，如果合法，就帮忙执行
	- 返回：操作系统执行完，通过sret指令回到用户态，APP继续执行

RISC-V的特权级：
- M Mode：机器最高权限，RustSBI就运行在这里，可以直接控制物理硬件、拦截中断
- S Mode：OS内核运行在这里，通过SBI向M Mode请求服务，同时管理U Mode
- U Mode：应用程序在这里运行。
层级关系：App  ->  OS  ->  RustSBI  ->  硬件

系统调用的一套流程：申请、穿越、执行、返回。统称为Trap陷入
在ecall和sret之间，还发生了上下文保存和恢复：
需要编写汇编代码，在切换模式的瞬间，把App的所有通用寄存器存到栈上，等执行完再还原。

当CPU触发异常将控制权交给OS时，有两种选择
- Kill：针对非法操作，如用户态想改内核数据，或执行了非法指令
- Handle & Resume：处理并恢复，针对合法但特殊的事件，如缺页异常、外设中断。OS处理完后，会让APP继续运行。

特权级机制是实现批处理和多任务的前提，保证了OS永远有能力夺回控制权。

在ch2要实现：批处理应用程序，实现特权级机制和切换

# 实现应用程序